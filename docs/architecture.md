# Production-Grade Go Backend Architecture Blueprint

its  in raw form !!

## ðŸ“ Complete Project Structure

```

```md 
project-root/  
â”œâ”€â”€ cmd/ # Main command-line applications  
â”‚ â”œâ”€â”€ api/ # Main API server  
â”‚ â”‚ â””â”€â”€ main.go  
â”‚ â”œâ”€â”€ worker/ # Background worker  
â”‚ â”‚ â””â”€â”€ main.go  
â”‚ â””â”€â”€ migrate/ # Database migrations CLI  
â”‚ â””â”€â”€ main.go  
â”œâ”€â”€ internal/ # Private application code  
â”‚ â”œâ”€â”€ config/ # Configuration management  
â”‚ â”‚ â”œâ”€â”€ config.go  
â”‚ â”‚ â”œâ”€â”€ database.go  
â”‚ â”‚ â”œâ”€â”€ redis.go  
â”‚ â”‚ â””â”€â”€ validator.go  
â”‚ â”œâ”€â”€ middleware/ # HTTP middleware  
â”‚ â”‚ â”œâ”€â”€ auth.go  
â”‚ â”‚ â”œâ”€â”€ cors.go  
â”‚ â”‚ â”œâ”€â”€ logger.go  
â”‚ â”‚ â”œâ”€â”€ rate_limiter.go  
â”‚ â”‚ â”œâ”€â”€ recovery.go  
â”‚ â”‚ â”œâ”€â”€ request_context.go  
â”‚ â”‚ â””â”€â”€ validator.go  
â”‚ â”œâ”€â”€ modules/ # Feature modules (domain-driven)  
â”‚ â”‚ â”œâ”€â”€ auth/  
â”‚ â”‚ â”‚ â”œâ”€â”€ dto/ # Data Transfer Objects  
â”‚ â”‚ â”‚ â”‚ â”œâ”€â”€ request.go  
â”‚ â”‚ â”‚ â”‚ â””â”€â”€ response.go  
â”‚ â”‚ â”‚ â”œâ”€â”€ handler.go # HTTP handlers (controllers)  
â”‚ â”‚ â”‚ â”œâ”€â”€ repository.go # Database operations  
â”‚ â”‚ â”‚ â”œâ”€â”€ routes.go # Route definitions  
â”‚ â”‚ â”‚ â”œâ”€â”€ service.go # Business logic  
â”‚ â”‚ â”‚ â””â”€â”€ validator.go # Request validation  
â”‚ â”‚ â”œâ”€â”€ users/  
â”‚ â”‚ â”‚   â”œâ”€â”€ dto/  
â”‚ â”‚ â”‚   â”‚ â”œâ”€â”€ request.go  
â”‚ â”‚ â”‚   â”‚ â””â”€â”€ response.go  
â”‚ â”‚ â”‚   â”œâ”€â”€ handler.go  
â”‚ â”‚ â”‚   â”œâ”€â”€ repository.go  
â”‚ â”‚ â”‚   â”œâ”€â”€ routes.go  
â”‚ â”‚ â”‚   â”œâ”€â”€ service.go  
â”‚ â”‚ â”‚   â””â”€â”€ validator.go  
â”‚ â”‚ â”œâ”€â”€ posts/  
â”‚ â”‚ â”‚   â”œâ”€â”€ dto/  
â”‚ â”‚ â”‚   â”œâ”€â”€ handler.go  
â”‚ â”‚ â”‚   â”œâ”€â”€ repository.go  
â”‚ â”‚ â”‚   â”œâ”€â”€ routes.go  
â”‚ â”‚ â”‚   â”œâ”€â”€ service.go  
â”‚ â”‚ â”‚   â””â”€â”€ validator.go  
â”‚ â”‚ â””â”€â”€ notifications/  
â”‚ â”‚ â”œâ”€â”€ dto/  
â”‚ â”‚ â”œâ”€â”€ handler.go  
â”‚ â”‚ â”œâ”€â”€ repository.go  
â”‚ â”‚ â”œâ”€â”€ routes.go  
â”‚ â”‚ â”œâ”€â”€ service.go  
â”‚ â”‚ â””â”€â”€ validator.go  
â”‚ â”œâ”€â”€ models/ # Domain models (entities)  
â”‚ â”‚ â”œâ”€â”€ user.go  
â”‚ â”‚ â”œâ”€â”€ post.go  
â”‚ â”‚ â”œâ”€â”€ notification.go  
â”‚ â”‚ â””â”€â”€ base.go # Common model fields  
â”‚ â”œâ”€â”€ repository/ # Generic repository patterns  
â”‚ â”‚ â”œâ”€â”€ base.go  
â”‚ â”‚ â””â”€â”€ interfaces.go  
â”‚ â”œâ”€â”€ services/ # Shared services  
â”‚ â”‚ â”œâ”€â”€ cache/  
â”‚ â”‚ â”‚ â”œâ”€â”€ redis.go  
â”‚ â”‚ â”‚ â””â”€â”€ interface.go  
â”‚ â”‚ â”œâ”€â”€ queue/  
â”‚ â”‚ â”‚ â”œâ”€â”€ worker.go  
â”‚ â”‚ â”‚ â””â”€â”€ interface.go  
â”‚ â”‚ â”œâ”€â”€ upload/  
â”‚ â”‚ â”‚ â”œâ”€â”€ s3.go  
â”‚ â”‚ â”‚ â””â”€â”€ interface.go  
â”‚ â”‚ â””â”€â”€ email/  
â”‚ â”‚ â”œâ”€â”€ smtp.go  
â”‚ â”‚ â””â”€â”€ interface.go  
â”‚ â”œâ”€â”€ websocket/ # WebSocket/Socket.IO implementation  
â”‚ â”‚ â”œâ”€â”€ handlers/  
â”‚ â”‚ â”‚ â”œâ”€â”€ chat.go  
â”‚ â”‚ â”‚ â”œâ”€â”€ notification.go  
â”‚ â”‚ â”‚ â””â”€â”€ dashboard.go  
â”‚ â”‚ â”œâ”€â”€ middleware/  
â”‚ â”‚ â”‚ â”œâ”€â”€ auth.go  
â”‚ â”‚ â”‚ â””â”€â”€ rate_limit.go  
â”‚ â”‚ â”œâ”€â”€ events/  
â”‚ â”‚ â”‚ â”œâ”€â”€ chat.go  
â”‚ â”‚ â”‚ â””â”€â”€ notification.go  
â”‚ â”‚ â”œâ”€â”€ hub.go # WebSocket hub/manager  
â”‚ â”‚ â”œâ”€â”€ client.go # WebSocket client  
â”‚ â”‚ â””â”€â”€ message.go # Message types  
â”‚ â”œâ”€â”€ database/ # Database connection & migrations  
â”‚ â”‚ â”œâ”€â”€ postgres.go  
â”‚ â”‚ â”œâ”€â”€ mongodb.go  
â”‚ â”‚ â””â”€â”€ migrations/  
â”‚ â”‚ â””â”€â”€ 001_initial.sql  
â”‚ â”œâ”€â”€ docs/ # API documentation  
â”‚ â”‚ â”œâ”€â”€ docs.go # Generated by swaggo  
â”‚ â”‚ â”œâ”€â”€ swagger.json  
â”‚ â”‚ â””â”€â”€ swagger.yaml  
â”‚ â””â”€â”€ utils/ # Utility functions  
â”‚ â”œâ”€â”€ response/  
â”‚ â”‚ â”œâ”€â”€ api_response.go  
â”‚ â”‚ â”œâ”€â”€ error.go  
â”‚ â”‚ â””â”€â”€ pagination.go  
â”‚ â”œâ”€â”€ jwt/  
â”‚ â”‚ â”œâ”€â”€ jwt.go  
â”‚ â”‚ â””â”€â”€ claims.go  
â”‚ â”œâ”€â”€ password/  
â”‚ â”‚ â””â”€â”€ hash.go  
â”‚ â”œâ”€â”€ logger/  
â”‚ â”‚ â”œâ”€â”€ logger.go  
â”‚ â”‚ â””â”€â”€ context.go  
â”‚ â”œâ”€â”€ validator/  
â”‚ â”‚ â””â”€â”€ custom.go  
â”‚ â””â”€â”€ helpers/  
â”‚ â”œâ”€â”€ string.go  
â”‚ â”œâ”€â”€ time.go  
â”‚ â””â”€â”€ id.go  
â”œâ”€â”€ pkg/ # Public reusable packages  
â”‚ â”œâ”€â”€ errors/  
â”‚ â”‚ â”œâ”€â”€ codes.go  
â”‚ â”‚ â””â”€â”€ errors.go  
â”‚ â”œâ”€â”€ pagination/  
â”‚ â”‚ â””â”€â”€ paginator.go  
â”‚ â””â”€â”€ constants/  
â”‚ â””â”€â”€ constants.go  
â”œâ”€â”€ migrations/ # SQL migration files  
â”‚ â”œâ”€â”€ 000001_create_users_table.up.sql  
â”‚ â”œâ”€â”€ 000001_create_users_table.down.sql  
â”‚ â”œâ”€â”€ 000002_create_posts_table.up.sql  
â”‚ â””â”€â”€ 000002_create_posts_table.down.sql  
â”œâ”€â”€ scripts/ # Build & deployment scripts  
â”‚ â”œâ”€â”€ build.sh  
â”‚ â”œâ”€â”€ test.sh  
â”‚ â””â”€â”€ docker-entrypoint.sh  
â”œâ”€â”€ test/ # Integration & E2E tests  
â”‚ â”œâ”€â”€ integration/  
â”‚ â”‚ â””â”€â”€ auth_test.go  
â”‚ â””â”€â”€ e2e/  
â”‚ â””â”€â”€ api_test.go  
â”œâ”€â”€ docs/ # Project documentation  
â”‚ â”œâ”€â”€ ARCHITECTURE.md  
â”‚ â”œâ”€â”€ API.md  
â”‚ â””â”€â”€ DEPLOYMENT.md  
â”œâ”€â”€ .github/ # GitHub workflows  
â”‚ â””â”€â”€ workflows/  
â”‚ â”œâ”€â”€ ci.yml  
â”‚ â””â”€â”€ deploy.yml  
â”œâ”€â”€ deployments/ # Deployment configs  
â”‚ â”œâ”€â”€ docker/  
â”‚ â”‚ â”œâ”€â”€ Dockerfile  
â”‚ â”‚ â””â”€â”€ docker-compose.yml  
â”‚ â””â”€â”€ kubernetes/  
â”‚ â”œâ”€â”€ deployment.yaml  
â”‚ â””â”€â”€ service.yaml  
â”œâ”€â”€ .env.example  
â”œâ”€â”€ .gitignore  
â”œâ”€â”€ go.mod  
â”œâ”€â”€ go.sum  
â”œâ”€â”€ Makefile  
â””â”€â”€ README.md
```

---

## ðŸ—ï¸ Core Architecture Components

### 1. **Configuration Management** (`internal/config/config.go`)

```go
package config

import (
	"fmt"
	"time"

	"github.com/spf13/viper"
)

type Config struct {
	App      AppConfig
	Server   ServerConfig
	Database DatabaseConfig
	Redis    RedisConfig
	JWT      JWTConfig
	Upload   UploadConfig
	Logger   LoggerConfig
}

type AppConfig struct {
	Name        string
	Environment string
	Version     string
	Debug       bool
}

type ServerConfig struct {
	Host            string
	Port            int
	ReadTimeout     time.Duration
	WriteTimeout    time.Duration
	ShutdownTimeout time.Duration
	CORS            CORSConfig
	RateLimit       RateLimitConfig
}

type CORSConfig struct {
	AllowedOrigins   []string
	AllowedMethods   []string
	AllowedHeaders   []string
	AllowCredentials bool
}

type RateLimitConfig struct {
	RequestsPerSecond int
	Burst             int
}

type DatabaseConfig struct {
	Host         string
	Port         int
	User         string
	Password     string
	Name         string
	SSLMode      string
	MaxOpenConns int
	MaxIdleConns int
	MaxLifetime  time.Duration
}

type RedisConfig struct {
	Host     string
	Port     int
	Password string
	DB       int
	PoolSize int
}

type JWTConfig struct {
	Secret           string
	AccessExpiry     time.Duration
	RefreshExpiry    time.Duration
	Issuer           string
}

type UploadConfig struct {
	Provider  string // "s3", "local"
	MaxSize   int64
	S3        S3Config
	LocalPath string
}

type S3Config struct {
	Bucket    string
	Region    string
	AccessKey string
	SecretKey string
}

type LoggerConfig struct {
	Level      string // "debug", "info", "warn", "error"
	Format     string // "json", "text"
	Output     string // "stdout", "file"
	FilePath   string
}

// LoadConfig loads configuration from environment variables and config files
func LoadConfig() (*Config, error) {
	v := viper.New()

	// Set config file paths
	v.SetConfigName("config")
	v.SetConfigType("yaml")
	v.AddConfigPath(".")
	v.AddConfigPath("./config")

	// Auto-bind environment variables
	v.AutomaticEnv()

	// Read config file (optional)
	if err := v.ReadInConfig(); err != nil {
		if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
			return nil, fmt.Errorf("failed to read config file: %w", err)
		}
	}

	var cfg Config

	// App Config
	cfg.App.Name = v.GetString("APP_NAME")
	cfg.App.Environment = v.GetString("APP_ENV")
	cfg.App.Version = v.GetString("APP_VERSION")
	cfg.App.Debug = v.GetBool("APP_DEBUG")

	// Server Config
	cfg.Server.Host = v.GetString("SERVER_HOST")
	cfg.Server.Port = v.GetInt("SERVER_PORT")
	cfg.Server.ReadTimeout = v.GetDuration("SERVER_READ_TIMEOUT") * time.Second
	cfg.Server.WriteTimeout = v.GetDuration("SERVER_WRITE_TIMEOUT") * time.Second
	cfg.Server.ShutdownTimeout = v.GetDuration("SERVER_SHUTDOWN_TIMEOUT") * time.Second

	// Database Config
	cfg.Database.Host = v.GetString("DB_HOST")
	cfg.Database.Port = v.GetInt("DB_PORT")
	cfg.Database.User = v.GetString("DB_USER")
	cfg.Database.Password = v.GetString("DB_PASSWORD")
	cfg.Database.Name = v.GetString("DB_NAME")
	cfg.Database.SSLMode = v.GetString("DB_SSLMODE")
	cfg.Database.MaxOpenConns = v.GetInt("DB_MAX_OPEN_CONNS")
	cfg.Database.MaxIdleConns = v.GetInt("DB_MAX_IDLE_CONNS")
	cfg.Database.MaxLifetime = v.GetDuration("DB_MAX_LIFETIME") * time.Minute

	// Redis Config
	cfg.Redis.Host = v.GetString("REDIS_HOST")
	cfg.Redis.Port = v.GetInt("REDIS_PORT")
	cfg.Redis.Password = v.GetString("REDIS_PASSWORD")
	cfg.Redis.DB = v.GetInt("REDIS_DB")
	cfg.Redis.PoolSize = v.GetInt("REDIS_POOL_SIZE")

	// JWT Config
	cfg.JWT.Secret = v.GetString("JWT_SECRET")
	cfg.JWT.AccessExpiry = v.GetDuration("JWT_ACCESS_EXPIRY") * time.Hour
	cfg.JWT.RefreshExpiry = v.GetDuration("JWT_REFRESH_EXPIRY") * time.Hour
	cfg.JWT.Issuer = v.GetString("JWT_ISSUER")

	// Logger Config
	cfg.Logger.Level = v.GetString("LOG_LEVEL")
	cfg.Logger.Format = v.GetString("LOG_FORMAT")
	cfg.Logger.Output = v.GetString("LOG_OUTPUT")
	cfg.Logger.FilePath = v.GetString("LOG_FILE_PATH")

	return &cfg, nil
}

// Validate validates the configuration
func (c *Config) Validate() error {
	if c.App.Name == "" {
		return fmt.Errorf("APP_NAME is required")
	}
	if c.JWT.Secret == "" {
		return fmt.Errorf("JWT_SECRET is required")
	}
	if c.Database.Host == "" {
		return fmt.Errorf("DB_HOST is required")
	}
	return nil
}
````

---

### 2. **Standardized API Response** (`internal/utils/response/api_response.go`)

```go
package response

import (
	"time"

	"github.com/gin-gonic/gin"
)

// Response represents the standard API response structure
type Response struct {
	Success   bool        `json:"success"`
	Message   string      `json:"message"`
	Data      interface{} `json:"data,omitempty"`
	Errors    []Error     `json:"errors,omitempty"`
	Meta      Meta        `json:"meta"`
	Code      string      `json:"code,omitempty"`
}

// Error represents a single error detail
type Error struct {
	Field   string `json:"field,omitempty"`
	Message string `json:"message"`
	Code    string `json:"code,omitempty"`
}

// Meta contains request metadata
type Meta struct {
	RequestID  string  `json:"requestId"`
	Timestamp  string  `json:"timestamp"`
	DurationMs float64 `json:"durationMs,omitempty"`
	Path       string  `json:"path"`
	Method     string  `json:"method"`
	Version    string  `json:"version,omitempty"`
}

// Success sends a successful response
func Success(c *gin.Context, data interface{}, message string, code ...string) {
	statusCode := 200
	if c.Request.Method == "POST" {
		statusCode = 201
	}

	resp := Response{
		Success: true,
		Message: message,
		Data:    data,
		Meta:    extractMeta(c),
	}

	if len(code) > 0 {
		resp.Code = code[0]
	}

	c.JSON(statusCode, resp)
}

// Error sends an error response
func Error(c *gin.Context, statusCode int, message string, errors []Error, code ...string) {
	resp := Response{
		Success: false,
		Message: message,
		Errors:  errors,
		Meta:    extractMeta(c),
	}

	if len(code) > 0 {
		resp.Code = code[0]
	}

	c.JSON(statusCode, resp)
}

// ValidationError sends a validation error response
func ValidationError(c *gin.Context, errors []Error) {
	Error(c, 422, "Validation failed", errors, "VALIDATION_ERROR")
}

// NotFound sends a 404 response
func NotFound(c *gin.Context, message string) {
	Error(c, 404, message, nil, "NOT_FOUND")
}

// Unauthorized sends a 401 response
func Unauthorized(c *gin.Context, message string) {
	Error(c, 401, message, nil, "UNAUTHORIZED")
}

// Forbidden sends a 403 response
func Forbidden(c *gin.Context, message string) {
	Error(c, 403, message, nil, "FORBIDDEN")
}

// InternalError sends a 500 response
func InternalError(c *gin.Context, message string) {
	Error(c, 500, message, nil, "INTERNAL_ERROR")
}

// extractMeta extracts metadata from the context
func extractMeta(c *gin.Context) Meta {
	requestID, _ := c.Get("requestID")
	startTime, exists := c.Get("startTime")
	
	meta := Meta{
		RequestID: requestID.(string),
		Timestamp: time.Now().UTC().Format(time.RFC3339),
		Path:      c.Request.URL.Path,
		Method:    c.Request.Method,
	}

	if exists {
		duration := time.Since(startTime.(time.Time))
		meta.DurationMs = float64(duration.Microseconds()) / 1000
	}

	version, exists := c.Get("version")
	if exists {
		meta.Version = version.(string)
	}

	return meta
}

// Paginated sends a paginated response
func Paginated(c *gin.Context, data interface{}, pagination PaginationMeta, message string) {
	resp := Response{
		Success: true,
		Message: message,
		Data:    data,
		Meta:    extractMeta(c),
	}

	// Add pagination to meta
	c.Set("pagination", pagination)

	c.JSON(200, gin.H{
		"success":    resp.Success,
		"message":    resp.Message,
		"data":       resp.Data,
		"meta":       resp.Meta,
		"pagination": pagination,
	})
}

// PaginationMeta represents pagination metadata
type PaginationMeta struct {
	Total      int64 `json:"total"`
	Page       int   `json:"page"`
	Limit      int   `json:"limit"`
	TotalPages int   `json:"totalPages"`
	HasNext    bool  `json:"hasNext"`
	HasPrev    bool  `json:"hasPrev"`
}

// NewPaginationMeta creates pagination metadata
func NewPaginationMeta(total int64, page, limit int) PaginationMeta {
	totalPages := int(total) / limit
	if int(total)%limit > 0 {
		totalPages++
	}

	return PaginationMeta{
		Total:      total,
		Page:       page,
		Limit:      limit,
		TotalPages: totalPages,
		HasNext:    page < totalPages,
		HasPrev:    page > 1,
	}
}
```

---

### 3. **Custom Error Handling** (`internal/utils/response/error.go`)

```go
package response

import (
	"fmt"
	"net/http"
)

// AppError represents a custom application error
type AppError struct {
	StatusCode int
	Message    string
	Code       string
	Errors     []Error
	Internal   error // Internal error for logging (not exposed to client)
}

// Error implements the error interface
func (e *AppError) Error() string {
	return e.Message
}

// NewAppError creates a new AppError
func NewAppError(statusCode int, message, code string, errors []Error, internal error) *AppError {
	return &AppError{
		StatusCode: statusCode,
		Message:    message,
		Code:       code,
		Errors:     errors,
		Internal:   internal,
	}
}

// Common error constructors

// BadRequest creates a 400 error
func BadRequest(message string, errors ...Error) *AppError {
	return NewAppError(http.StatusBadRequest, message, "BAD_REQUEST", errors, nil)
}

// Unauthorized creates a 401 error
func UnauthorizedError(message string) *AppError {
	return NewAppError(http.StatusUnauthorized, message, "UNAUTHORIZED", nil, nil)
}

// Forbidden creates a 403 error
func ForbiddenError(message string) *AppError {
	return NewAppError(http.StatusForbidden, message, "FORBIDDEN", nil, nil)
}

// NotFoundError creates a 404 error
func NotFoundError(resource string) *AppError {
	return NewAppError(
		http.StatusNotFound,
		fmt.Sprintf("%s not found", resource),
		"NOT_FOUND",
		nil,
		nil,
	)
}

// ValidationErrors creates a 422 error
func ValidationErrors(errors []Error) *AppError {
	return NewAppError(
		http.StatusUnprocessableEntity,
		"Validation failed",
		"VALIDATION_ERROR",
		errors,
		nil,
	)
}

// InternalServerError creates a 500 error
func InternalServerError(message string, internal error) *AppError {
	if message == "" {
		message = "An internal error occurred"
	}
	return NewAppError(
		http.StatusInternalServerError,
		message,
		"INTERNAL_ERROR",
		nil,
		internal,
	)
}

// ConflictError creates a 409 error
func ConflictError(message string) *AppError {
	return NewAppError(http.StatusConflict, message, "CONFLICT", nil, nil)
}

// TooManyRequests creates a 429 error
func TooManyRequests(message string) *AppError {
	if message == "" {
		message = "Too many requests, please try again later"
	}
	return NewAppError(http.StatusTooManyRequests, message, "RATE_LIMIT_EXCEEDED", nil, nil)
}

// ServiceUnavailable creates a 503 error
func ServiceUnavailable(message string) *AppError {
	if message == "" {
		message = "Service temporarily unavailable"
	}
	return NewAppError(http.StatusServiceUnavailable, message, "SERVICE_UNAVAILABLE", nil, nil)
}
```

---

### 4. **Request Context Middleware** (`internal/middleware/request_context.go`)

```go
package middleware

import (
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// RequestContext adds request ID and timing to context
func RequestContext(version string) gin.HandlerFunc {
	return func(c *gin.Context) {
		// Generate or extract request ID
		requestID := c.GetHeader("X-Request-ID")
		if requestID == "" {
			requestID = uuid.New().String()
		}

		// Add to context
		c.Set("requestID", requestID)
		c.Set("startTime", time.Now())
		c.Set("version", version)

		// Add to response headers
		c.Header("X-Request-ID", requestID)

		c.Next()
	}
}
```

---

### 5. **Error Handler Middleware** (`internal/middleware/recovery.go`)

```go
package middleware

import (
	"fmt"
	"net/http"

	"github.com/gin-gonic/gin"
	"your-project/internal/utils/logger"
	"your-project/internal/utils/response"
)

// Recovery handles panics and converts them to proper error responses
func Recovery() gin.HandlerFunc {
	return func(c *gin.Context) {
		defer func() {
			if err := recover(); err != nil {
				requestID, _ := c.Get("requestID")
				
				logger.Error("panic recovered",
					"requestID", requestID,
					"error", err,
					"path", c.Request.URL.Path,
					"method", c.Request.Method,
				)

				// Check if it's an AppError
				if appErr, ok := err.(*response.AppError); ok {
					response.Error(c, appErr.StatusCode, appErr.Message, appErr.Errors, appErr.Code)
					return
				}

				// Generic error
				response.InternalError(c, "An unexpected error occurred")
				c.Abort()
			}
		}()

		c.Next()

		// Handle errors set in context
		if len(c.Errors) > 0 {
			err := c.Errors.Last()
			
			requestID, _ := c.Get("requestID")
			logger.Error("request error",
				"requestID", requestID,
				"error", err.Error(),
				"path", c.Request.URL.Path,
			)

			// Check if it's an AppError
			if appErr, ok := err.Err.(*response.AppError); ok {
				if appErr.Internal != nil {
					logger.Error("internal error details",
						"requestID", requestID,
						"internal", appErr.Internal.Error(),
					)
				}
				response.Error(c, appErr.StatusCode, appErr.Message, appErr.Errors, appErr.Code)
				return
			}

			// Default error response
			response.InternalError(c, err.Error())
		}
	}
}

// ErrorHandler is a simpler error handling middleware
func ErrorHandler() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Next()

		// Check if response already sent
		if c.Writer.Written() {
			return
		}

		// Check for errors in context
		if len(c.Errors) > 0 {
			err := c.Errors.Last().Err

			// Handle AppError
			if appErr, ok := err.(*response.AppError); ok {
				response.Error(c, appErr.StatusCode, appErr.Message, appErr.Errors, appErr.Code)
				return
			}

			// Generic error
			response.InternalError(c, "An error occurred")
		}
	}
}
```

---

### 6. **Module Pattern Example** (`internal/modules/auth/`)

#### **Handler** (`internal/modules/auth/handler.go`)

```go
package auth

import (
	"github.com/gin-gonic/gin"
	"your-project/internal/modules/auth/dto"
	"your-project/internal/utils/response"
)

type Handler struct {
	service *Service
}

func NewHandler(service *Service) *Handler {
	return &Handler{service: service}
}

// Register godoc
// @Summary Register a new user
// @Description Create a new user account
// @Tags auth
// @Accept json
// @Produce json
// @Param request body dto.RegisterRequest true "Registration details"
// @Success 201 {object} response.Response{data=dto.AuthResponse}
// @Failure 400 {object} response.Response
// @Failure 422 {object} response.Response
// @Router /auth/register [post]
func (h *Handler) Register(c *gin.Context) {
	var req dto.RegisterRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.Error(response.BadRequest("Invalid request body"))
		return
	}

	// Validate
	if err := req.Validate(); err != nil {
		c.Error(err)
		return
	}

	// Call service
	authResp, err := h.service.Register(c.Request.Context(), req)
	if err != nil {
		c.Error(err)
		return
	}

	response.Success(c, authResp, "User registered successfully")
}

// Login godoc
// @Summary User login
// @Description Authenticate user and get tokens
// @Tags auth
// @Accept json
// @Produce json
// @Param request body dto.LoginRequest true "Login credentials"
// @Success 200 {object} response.Response{data=dto.AuthResponse}
// @Failure 401 {object} response.Response
// @Router /auth/login [post]
func (h *Handler) Login(c *gin.Context) {
	var req dto.LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.Error(response.BadRequest("Invalid request body"))
		return
	}

	if err := req.Validate(); err != nil {
		c.Error(err)
		return
	}

	authResp, err := h.service.Login(c.Request.Context(), req)
	if err != nil {
		c.Error(err)
		return
	}

	response.Success(c, authResp, "Login successful")
}

// RefreshToken godoc
// @Summary Refresh access token
// @Description Get new access token using refresh token
// @Tags auth
// @Accept json
// @Produce json
// @Param request body dto.RefreshRequest true "Refresh token"
// @Success 200 {object} response.Response{data=dto.TokenResponse}
// @Failure 401 {object} response.Response
// @Router /auth/refresh [post]
func (h *Handler) RefreshToken(c *gin.Context) {
	var req dto.RefreshRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.Error(response.BadRequest("Invalid request body"))
		return
	}

	tokenResp, err := h.service.RefreshToken(c.Request.Context(), req.RefreshToken)
	if err != nil {
		c.Error(err)
		return
	}

	response.Success(c, tokenResp, "Token refreshed successfully")
}

// Logout godoc
// @Summary User logout
// @Description Invalidate user session
// @Tags auth
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} response.Response
// @Failure 401 {object} response.Response
// @Router /auth/logout [post]
func (h *Handler) Logout(c *gin.Context) {
	userID, _ := c.Get("userID")
	
	if err := h.service.Logout(c.Request.Context(), userID.(string)); err != nil {
		c.Error(err)
		return
	}

	response.Success(c, nil, "Logout successful")
}

// GetProfile godoc
// @Summary Get user profile
// @Description Get authenticated user's profile
// @Tags auth
// @Produce json
// @Security BearerAuth
// @Success 200 {object} response.Response{data=dto.UserResponse}
// @Failure 401 {object} response.Response
// @Router /auth/profile [get]
func (h *Handler) GetProfile(c *gin.Context) {
	userID, _ := c.Get("userID")
	
	user, err := h.service.GetProfile(c.Request.Context(), userID.(string))
	if err != nil {
		c.Error(err)
		return
	}

	response.Success(c, user, "Profile fetched successfully")
}
```

#### **Service** (`internal/modules/auth/service.go`)

```go
)
	return emailRegex.MatchString(email)
}
```

#### **DTOs** (`internal/modules/auth/dto/response.go`)

```go
package dto

import (
	"time"
	"your-project/internal/models"
)

type AuthResponse struct {
	User         *UserResponse `json:"user"`
	AccessToken  string        `json:"accessToken"`
	RefreshToken string        `json:"refreshToken"`
	ExpiresIn    int           `json:"expiresIn"`
}

type TokenResponse struct {
	AccessToken string `json:"accessToken"`
	ExpiresIn   int    `json:"expiresIn"`
}

type UserResponse struct {
	ID        string    `json:"id"`
	Name      string    `json:"name"`
	Email     string    `json:"email"`
	Role      string    `json:"role"`
	Status    string    `json:"status"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func ToUserResponse(user *models.User) *UserResponse {
	return &UserResponse{
		ID:        user.ID,
		Name:      user.Name,
		Email:     user.Email,
		Role:      user.Role,
		Status:    user.Status,
		CreatedAt: user.CreatedAt,
		UpdatedAt: user.UpdatedAt,
	}
}
```

#### **Routes** (`internal/modules/auth/routes.go`)

```go
package auth

import (
	"github.com/gin-gonic/gin"
	"your-project/internal/middleware"
)

func RegisterRoutes(router *gin.RouterGroup, handler *Handler, authMiddleware gin.HandlerFunc) {
	auth := router.Group("/auth")
	{
		// Public routes
		auth.POST("/register", handler.Register)
		auth.POST("/login", handler.Login)
		auth.POST("/refresh", handler.RefreshToken)

		// Protected routes
		auth.Use(authMiddleware)
		auth.POST("/logout", handler.Logout)
		auth.GET("/profile", handler.GetProfile)
	}
}
```

---

### 7. **JWT Utility** (`internal/utils/jwt/jwt.go`)

```go
package jwt

import (
	"errors"
	"time"

	"github.com/golang-jwt/jwt/v5"
)

type Claims struct {
	UserID string `json:"userId"`
	Role   string `json:"role"`
	jwt.RegisteredClaims
}

// GenerateAccessToken creates a new access token
func GenerateAccessToken(userID, secret string, expiry time.Duration) (string, error) {
	claims := Claims{
		UserID: userID,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(expiry)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			NotBefore: jwt.NewNumericDate(time.Now()),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString([]byte(secret))
}

// GenerateRefreshToken creates a new refresh token
func GenerateRefreshToken(userID, secret string, expiry time.Duration) (string, error) {
	claims := Claims{
		UserID: userID,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(expiry)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString([]byte(secret))
}

// VerifyToken validates and parses a JWT token
func VerifyToken(tokenString, secret string) (*Claims, error) {
	token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		return []byte(secret), nil
	})

	if err != nil {
		return nil, err
	}

	if claims, ok := token.Claims.(*Claims); ok && token.Valid {
		return claims, nil
	}

	return nil, errors.New("invalid token")
}
```

---

### 8. **Auth Middleware** (`internal/middleware/auth.go`)

```go
package middleware

import (
	"strings"

	"github.com/gin-gonic/gin"
	"your-project/internal/config"
	"your-project/internal/utils/jwt"
	"your-project/internal/utils/response"
)

func Auth(cfg *config.Config) gin.HandlerFunc {
	return func(c *gin.Context) {
		// Extract token from header
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.Error(response.UnauthorizedError("Authorization header required"))
			c.Abort()
			return
		}

		// Check Bearer prefix
		parts := strings.SplitN(authHeader, " ", 2)
		if len(parts) != 2 || parts[0] != "Bearer" {
			c.Error(response.UnauthorizedError("Invalid authorization header format"))
			c.Abort()
			return
		}

		tokenString := parts[1]

		// Verify token
		claims, err := jwt.VerifyToken(tokenString, cfg.JWT.Secret)
		if err != nil {
			c.Error(response.UnauthorizedError("Invalid or expired token"))
			c.Abort()
			return
		}

		// Set user info in context
		c.Set("userID", claims.UserID)
		c.Set("role", claims.Role)

		c.Next()
	}
}

// RequireRole checks if user has required role
func RequireRole(roles ...string) gin.HandlerFunc {
	return func(c *gin.Context) {
		userRole, exists := c.Get("role")
		if !exists {
			c.Error(response.ForbiddenError("Insufficient permissions"))
			c.Abort()
			return
		}

		roleStr := userRole.(string)
		for _, role := range roles {
			if roleStr == role {
				c.Next()
				return
			}
		}

		c.Error(response.ForbiddenError("Insufficient permissions"))
		c.Abort()
	}
}
```

---

### 9. **Logger Utility** (`internal/utils/logger/logger.go`)

```go
package logger

import (
	"os"

	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"your-project/internal/config"
)

var log *zap.Logger

// Initialize sets up the logger
func Initialize(cfg *config.LoggerConfig) error {
	var zapConfig zap.Config

	if cfg.Format == "json" {
		zapConfig = zap.NewProductionConfig()
	} else {
		zapConfig = zap.NewDevelopmentConfig()
	}

	// Set log level
	level, err := zapcore.ParseLevel(cfg.Level)
	if err != nil {
		level = zapcore.InfoLevel
	}
	zapConfig.Level = zap.NewAtomicLevelAt(level)

	// Configure output
	if cfg.Output == "file" && cfg.FilePath != "" {
		zapConfig.OutputPaths = []string{cfg.FilePath}
		zapConfig.ErrorOutputPaths = []string{cfg.FilePath}
	} else {
		zapConfig.OutputPaths = []string{"stdout"}
		zapConfig.ErrorOutputPaths = []string{"stderr"}
	}

	logger, err := zapConfig.Build()
	if err != nil {
		return err
	}

	log = logger
	return nil
}

// Get returns the logger instance
func Get() *zap.Logger {
	if log == nil {
		// Fallback logger
		log, _ = zap.NewProduction()
	}
	return log
}

// Helper functions for common log levels
func Debug(msg string, fields ...interface{}) {
	Get().Sugar().Debugw(msg, fields...)
}

func Info(msg string, fields ...interface{}) {
	Get().Sugar().Infow(msg, fields...)
}

func Warn(msg string, fields ...interface{}) {
	Get().Sugar().Warnw(msg, fields...)
}

func Error(msg string, fields ...interface{}) {
	Get().Sugar().Errorw(msg, fields...)
}

func Fatal(msg string, fields ...interface{}) {
	Get().Sugar().Fatalw(msg, fields...)
}

// Sync flushes any buffered log entries
func Sync() {
	if log != nil {
		log.Sync()
	}
}
```

---

### 10. **Database Connection** (`internal/database/postgres.go`)

```go
package database

import (
	"fmt"
	"time"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	gormlogger "gorm.io/gorm/logger"
	"your-project/internal/config"
	"your-project/internal/utils/logger"
)

func ConnectPostgres(cfg *config.DatabaseConfig) (*gorm.DB, error) {
	dsn := fmt.Sprintf(
		"host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
		cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.Name, cfg.SSLMode,
	)

	// Configure GORM logger
	gormLogger := gormlogger.Default.LogMode(gormlogger.Silent)
	if cfg.LogQueries {
		gormLogger = gormlogger.Default.LogMode(gormlogger.Info)
	}

	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
		Logger: gormLogger,
		NowFunc: func() time.Time {
			return time.Now().UTC()
		},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	sqlDB, err := db.DB()
	if err != nil {
		return nil, fmt.Errorf("failed to get database instance: %w", err)
	}

	// Connection pool settings
	sqlDB.SetMaxOpenConns(cfg.MaxOpenConns)
	sqlDB.SetMaxIdleConns(cfg.MaxIdleConns)
	sqlDB.SetConnMaxLifetime(cfg.MaxLifetime)

	// Test connection
	if err := sqlDB.Ping(); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	logger.Info("database connected successfully",
		"host", cfg.Host,
		"database", cfg.Name,
	)

	return db, nil
}

// Close closes the database connection
func Close(db *gorm.DB) error {
	sqlDB, err := db.DB()
	if err != nil {
		return err
	}
	return sqlDB.Close()
}
```

---

### 11. **Redis Service** (`internal/services/cache/redis.go`)

```go
package cache

import (
	"context"
	"fmt"
	"time"

	"github.com/redis/go-redis/v9"
	"your-project/internal/config"
	"your-project/internal/utils/logger"
)

type Service interface {
	Get(ctx context.Context, key string) (string, error)
	Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error
	Delete(ctx context.Context, key string) error
	Exists(ctx context.Context, key string) (bool, error)
	Increment(ctx context.Context, key string) (int64, error)
	Expire(ctx context.Context, key string, ttl time.Duration) error
}

type redisService struct {
	client *redis.Client
}

func NewRedisService(cfg *config.RedisConfig) (Service, error) {
	client := redis.NewClient(&redis.Options{
		Addr:     fmt.Sprintf("%s:%d", cfg.Host, cfg.Port),
		Password: cfg.Password,
		DB:       cfg.DB,
		PoolSize: cfg.PoolSize,
	})

	// Test connection
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := client.Ping(ctx).Err(); err != nil {
		return nil, fmt.Errorf("failed to connect to Redis: %w", err)
	}

	logger.Info("redis connected successfully",
		"host", cfg.Host,
		"port", cfg.Port,
	)

	return &redisService{client: client}, nil
}

func (s *redisService) Get(ctx context.Context, key string) (string, error) {
	return s.client.Get(ctx, key).Result()
}

func (s *redisService) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error {
	return s.client.Set(ctx, key, value, ttl).Err()
}

func (s *redisService) Delete(ctx context.Context, key string) error {
	return s.client.Del(ctx, key).Err()
}

func (s *redisService) Exists(ctx context.Context, key string) (bool, error) {
	count, err := s.client.Exists(ctx, key).Result()
	return count > 0, err
}

func (s *redisService) Increment(ctx context.Context, key string) (int64, error) {
	return s.client.Incr(ctx, key).Result()
}

func (s *redisService) Expire(ctx context.Context, key string, ttl time.Duration) error {
	return s.client.Expire(ctx, key, ttl).Err()
}

func (s *redisService) Close() error {
	return s.client.Close()
}
```

---

### 12. **Main Application** (`cmd/api/main.go`)

```go
package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"

	"your-project/internal/config"
	"your-project/internal/database"
	"your-project/internal/middleware"
	"your-project/internal/modules/auth"
	"your-project/internal/services/cache"
	"your-project/internal/utils/logger"
	_ "your-project/internal/docs" // Import generated docs
)

// @title Your Project API
// @version 1.0
// @description Production-grade Go backend API
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.email support@yourproject.com

// @license.name MIT
// @license.url https://opensource.org/licenses/MIT

// @host localhost:8080
// @BasePath /api/v1

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

func main() {
	// Load configuration
	cfg, err := config.LoadConfig()
	if err != nil {
		fmt.Printf("Failed to load config: %v\n", err)
		os.Exit(1)
	}

	// Validate configuration
	if err := cfg.Validate(); err != nil {
		fmt.Printf("Invalid configuration: %v\n", err)
		os.Exit(1)
	}

	// Initialize logger
	if err := logger.Initialize(&cfg.Logger); err != nil {
		fmt.Printf("Failed to initialize logger: %v\n", err)
		os.Exit(1)
	}
	defer logger.Sync()

	logger.Info("starting application",
		"name", cfg.App.Name,
		"environment", cfg.App.Environment,
		"version", cfg.App.Version,
	)

	// Connect to database
	db, err := database.ConnectPostgres(&cfg.Database)
	if err != nil {
		logger.Fatal("failed to connect to database", "error", err)
	}
	defer database.Close(db)

	// Connect to Redis
	cacheService, err := cache.NewRedisService(&cfg.Redis)
	if err != nil {
		logger.Fatal("failed to connect to redis", "error", err)
	}

	// Setup Gin
	if cfg.App.Environment == "production" {
		gin.SetMode(gin.ReleaseMode)
	}

	router := gin.New()

	// Global middleware
	router.Use(middleware.RequestContext(cfg.App.Version))
	router.Use(middleware.Logger())
	router.Use(middleware.Recovery())
	router.Use(middleware.ErrorHandler())
	router.Use(middleware.CORS(cfg.Server.CORS))

	// Health check endpoints
	router.GET("/health", healthCheck)
	router.GET("/ready", readyCheck(db))

	// API routes
	v1 := router.Group("/api/v1")
	{
		// Rate limiter for API routes
		v1.Use(middleware.RateLimit(cfg.Server.RateLimit))

		// Auth module
		authRepo := auth.NewRepository(db)
		authService := auth.NewService(authRepo, cacheService, cfg)
		authHandler := auth.NewHandler(authService)
		authMiddleware := middleware.Auth(cfg)
		auth.RegisterRoutes(v1, authHandler, authMiddleware)

		// Add other modules here...
	}

	// Swagger documentation
	router.GET("/docs/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// Start server
	srv := &http.Server{
		Addr:         fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port),
		Handler:      router,
		ReadTimeout:  cfg.Server.ReadTimeout,
		WriteTimeout: cfg.Server.WriteTimeout,
	}

	// Graceful shutdown
	go func() {
		logger.Info("server starting",
			"host", cfg.Server.Host,
			"port", cfg.Server.Port,
		)

		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			logger.Fatal("failed to start server", "error", err)
		}
	}()

	// Wait for interrupt signal
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	logger.Info("shutting down server...")

	ctx, cancel := context.WithTimeout(context.Background(), cfg.Server.ShutdownTimeout)
	defer cancel()

	if err := srv.Shutdown(ctx); err != nil {
		logger.Error("server forced to shutdown", "error", err)
	}

	logger.Info("server stopped gracefully")
}

func healthCheck(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"status": "ok",
		"time":   time.Now().Format(time.RFC3339),
	})
}

func readyCheck(db interface{}) gin.HandlerFunc {
	return func(c *gin.Context) {
		// Add actual health checks here
		c.JSON(http.StatusOK, gin.H{
			"status":   "ready",
			"database": "connected",
			"time":     time.Now().Format(time.RFC3339),
		})
	}
}
```

---

### 13. **Models** (`internal/models/user.go`)

```go
package models

import (
	"time"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

type User struct {
	ID          string    `gorm:"type:uuid;primaryKey" json:"id"`
	Name        string    `gorm:"type:varchar(255);not null" json:"name"`
	Email       string    `gorm:"type:varchar(255);uniqueIndex;not null" json:"email"`
	Password    string    `gorm:"type:varchar(255);not null" json:"-"`
	Role        string    `gorm:"type:varchar(50);default:'user'" json:"role"`
	Status      string    `gorm:"type:varchar(50);default:'active'" json:"status"`
	LastLoginAt time.Time `gorm:"type:timestamp" json:"lastLoginAt,omitempty"`
	CreatedAt   time.Time `gorm:"autoCreateTime" json:"createdAt"`
	UpdatedAt   time.Time `gorm:"autoUpdateTime" json:"updatedAt"`
	DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`
}

// BeforeCreate hook to generate UUID
func (u *User) BeforeCreate(tx *gorm.DB) error {
	if u.ID == "" {
		u.ID = uuid.New().String()
	}
	return nil
}

// TableName specifies the table name
func (User) TableName() string {
	return "users"
}
```

---

### 14. **Rate Limiter Middleware** (`internal/middleware/rate_limiter.go`)

```go
package middleware

import (
	"fmt"
	"time"

	"github.com/gin-gonic/gin"
	"golang.org/x/time/rate"
	"your-project/internal/config"
	"your-project/internal/utils/response"
)

var limiters = make(map[string]*rate.Limiter)

func RateLimit(cfg config.RateLimitConfig) gin.HandlerFunc {
	return func(c *gin.Context) {
		ip := c.ClientIP()

		limiter, exists := limiters[ip]
		if !exists {
			limiter = rate.NewLimiter(rate.Limit(cfg.RequestsPerSecond), cfg.Burst)
			limiters[ip] = limiter
		}

		if !limiter.Allow() {
			c.Error(response.TooManyRequests("Rate limit exceeded"))
			c.Abort()
			return
		}

		c.Next()
	}
}
 
// RateLimitByKey creates a rate limiter based on custom key
func RateLimitByKey(keyFunc func(*gin.Context) string, requestsPerSecond int, burst int) gin.HandlerFunc {
	limiters := make(map[string]*rate.Limiter)

	return func(c *gin.Context) {
		key := keyFunc(c)

		limiter, exists := limiters[key]
		if !exists {
			limiter = rate.NewLimiter(rate.Limit(requestsPerSecond), burst)
			limiters[key] = limiter
		}

		if !limiter.Allow() {
			c.Error(response.TooManyRequests(fmt.Sprintf("Rate limit exceeded for key: %s", key)))
			c.Abort()
			return
		}

		c.Next()
	}
}
```

---

### 15. **CORS Middleware** (`internal/middleware/cors.go`)

```go
package middleware

import (
	"github.com/gin-gonic/gin"
	"your-project/internal/config"
)

func CORS(cfg config.CORSConfig) gin.HandlerFunc {
	return func(c *gin.Context) {
		// Set CORS headers
		origin := c.GetHeader("Origin")
		if isAllowedOrigin(origin, cfg.AllowedOrigins) {
			c.Header("Access-Control-Allow-Origin", origin)
		}

		c.Header("Access-Control-Allow-Methods", joinStrings(cfg.AllowedMethods, ", "))
		c.Header("Access-Control-Allow-Headers", joinStrings(cfg.AllowedHeaders, ", "))

		if cfg.AllowCredentials {
			c.Header("Access-Control-Allow-Credentials", "true")
		}

		// Handle preflight
		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(204)
			return
		}

		c.Next()
	}
}

func isAllowedOrigin(origin string, allowed []string) bool {
	for _, o := range allowed {
		if o == "*" || o == origin {
			return true
		}
	}
	return false
}

func joinStrings(strs []string, sep string) string {
	result := ""
	for i, s := range strs {
		if i > 0 {
			result += sep
		}
		result += s
	}
	return result
}
```

---

### 16. **Logger Middleware** (`internal/middleware/logger.go`)

```go
package middleware

import (
	"time"

	"github.com/gin-gonic/gin"
	"your-project/internal/utils/logger"
)

func Logger() gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path
		query := c.Request.URL.RawQuery

		c.Next()

		duration := time.Since(start)
		statusCode := c.Writer.Status()

		requestID, _ := c.Get("requestID")

		logger.Info("request completed",
			"requestID", requestID,
			"method", c.Request.Method,
			"path", path,
			"query", query,
			"status", statusCode,
			"duration", duration.Milliseconds(),
			"ip", c.ClientIP(),
			"userAgent", c.Request.UserAgent(),
		)
	}
}
```

---

### 17. **WebSocket Implementation** (`internal/websocket/hub.go`)

```go
package websocket

import (
	"sync"

	"your-project/internal/utils/logger"
)

// Hub manages WebSocket connections
type Hub struct {
	// Registered clients
	clients map[*Client]bool

	// Inbound messages from clients
	broadcast chan []byte

	// Register requests from clients
	register chan *Client

	// Unregister requests from clients
	unregister chan *Client

	// Mutex for thread-safe operations
	mu sync.RWMutex

	// User to clients mapping (for targeted messages)
	userClients map[string][]*Client
}

func NewHub() *Hub {
	return &Hub{
		broadcast:   make(chan []byte),
		register:    make(chan *Client),
		unregister:  make(chan *Client),
		clients:     make(map[*Client]bool),
		userClients: make(map[string][]*Client),
	}
}

func (h *Hub) Run() {
	for {
		select {
		case client := <-h.register:
			h.registerClient(client)

		case client := <-h.unregister:
			h.unregisterClient(client)

		case message := <-h.broadcast:
			h.broadcastMessage(message)
		}
	}
}

func (h *Hub) registerClient(client *Client) {
	h.mu.Lock()
	defer h.mu.Unlock()

	h.clients[client] = true

	// Add to user mapping
	if client.UserID != "" {
		h.userClients[client.UserID] = append(h.userClients[client.UserID], client)
	}

	logger.Info("client registered",
		"userID", client.UserID,
		"clientID", client.ID,
		"totalClients", len(h.clients),
	)
}

func (h *Hub) unregisterClient(client *Client) {
	h.mu.Lock()
	defer h.mu.Unlock()

	if _, ok := h.clients[client]; ok {
		delete(h.clients, client)
		close(client.send)

		// Remove from user mapping
		if client.UserID != "" {
			clients := h.userClients[client.UserID]
			for i, c := range clients {
				if c == client {
					h.userClients[client.UserID] = append(clients[:i], clients[i+1:]...)
					break
				}
			}
			// Clean up empty user entries
			if len(h.userClients[client.UserID]) == 0 {
				delete(h.userClients, client.UserID)
			}
		}

		logger.Info("client unregistered",
			"userID", client.UserID,
			"clientID", client.ID,
			"totalClients", len(h.clients),
		)
	}
}

func (h *Hub) broadcastMessage(message []byte) {
	h.mu.RLock()
	defer h.mu.RUnlock()

	for client := range h.clients {
		select {
		case client.send <- message:
		default:
			// Client send channel is full, close it
			close(client.send)
			delete(h.clients, client)
		}
	}
}

// SendToUser sends a message to all connections of a specific user
func (h *Hub) SendToUser(userID string, message []byte) {
	h.mu.RLock()
	defer h.mu.RUnlock()

	clients, exists := h.userClients[userID]
	if !exists {
		return
	}

	for _, client := range clients {
		select {
		case client.send <- message:
		default:
			logger.Warn("failed to send message to client", "userID", userID, "clientID", client.ID)
		}
	}
}

// GetConnectedUsers returns count of unique connected users
func (h *Hub) GetConnectedUsers() int {
	h.mu.RLock()
	defer h.mu.RUnlock()
	return len(h.userClients)
}

// GetTotalConnections returns total number of connections
func (h *Hub) GetTotalConnections() int {
	h.mu.RLock()
	defer h.mu.RUnlock()
	return len(h.clients)
}

// IsUserOnline checks if a user has any active connections
func (h *Hub) IsUserOnline(userID string) bool {
	h.mu.RLock()
	defer h.mu.RUnlock()
	clients, exists := h.userClients[userID]
	return exists && len(clients) > 0
}
```

---

### 18. **WebSocket Client** (`internal/websocket/client.go`)

```go
package websocket

import (
	"time"

	"github.com/google/uuid"
	"github.com/gorilla/websocket"
	"your-project/internal/utils/logger"
)

const (
	// Time allowed to write a message to the peer
	writeWait = 10 * time.Second

	// Time allowed to read the next pong message from the peer
	pongWait = 60 * time.Second

	// Send pings to peer with this period
	pingPeriod = (pongWait * 9) / 10

	// Maximum message size allowed from peer
	maxMessageSize = 512 * 1024 // 512 KB
)

type Client struct {
	ID     string
	UserID string
	hub    *Hub
	conn   *websocket.Conn
	send   chan []byte
}

func NewClient(hub *Hub, conn *websocket.Conn, userID string) *Client {
	return &Client{
		ID:     uuid.New().String(),
		UserID: userID,
		hub:    hub,
		conn:   conn,
		send:   make(chan []byte, 256),
	}
}

// ReadPump pumps messages from the websocket connection to the hub
func (c *Client) ReadPump() {
	defer func() {
		c.hub.unregister <- c
		c.conn.Close()
	}()

	c.conn.SetReadDeadline(time.Now().Add(pongWait))
	c.conn.SetPongHandler(func(string) error {
		c.conn.SetReadDeadline(time.Now().Add(pongWait))
		return nil
	})

	c.conn.SetReadLimit(maxMessageSize)

	for {
		_, message, err := c.conn.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				logger.Error("websocket error", "error", err, "userID", c.UserID)
			}
			break
		}

		// Handle incoming message
		c.handleMessage(message)
	}
}

// WritePump pumps messages from the hub to the websocket connection
func (c *Client) WritePump() {
	ticker := time.NewTicker(pingPeriod)
	defer func() {
		ticker.Stop()
		c.conn.Close()
	}()

	for {
		select {
		case message, ok := <-c.send:
			c.conn.SetWriteDeadline(time.Now().Add(writeWait))
			if !ok {
				// Hub closed the channel
				c.conn.WriteMessage(websocket.CloseMessage, []byte{})
				return
			}

			w, err := c.conn.NextWriter(websocket.TextMessage)
			if err != nil {
				return
			}
			w.Write(message)

			// Add queued messages to the current websocket message
			n := len(c.send)
			for i := 0; i < n; i++ {
				w.Write([]byte{'\n'})
				w.Write(<-c.send)
			}

			if err := w.Close(); err != nil {
				return
			}

		case <-ticker.C:
			c.conn.SetWriteDeadline(time.Now().Add(writeWait))
			if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {
				return
			}
		}
	}
}

func (c *Client) handleMessage(message []byte) {
	// Parse and handle different message types
	// This is where you'd implement your WebSocket protocol
	logger.Debug("received message", "userID", c.UserID, "message", string(message))
	
	// Example: broadcast to all
	c.hub.broadcast <- message
}
```

---

### 19. **Makefile** (Build Automation)

```makefile
# Makefile for Go project

.PHONY: help build run test clean migrate-up migrate-down swagger docker-build docker-run

# Variables
APP_NAME := your-project
VERSION := $(shell git describe --tags --always --dirty)
BUILD_DIR := ./bin
MAIN_PATH := ./cmd/api
MIGRATION_PATH := ./migrations

# Go parameters
GOCMD := go
GOBUILD := $(GOCMD) build
GOTEST := $(GOCMD) test
GOMOD := $(GOCMD) mod
GORUN := $(GOCMD) run

# Docker parameters
DOCKER_IMAGE := $(APP_NAME):$(VERSION)

help: ## Show this help message
	@echo "Usage: make [target]"
	@echo ""
	@echo "Available targets:"
	@grep -E '^[a-zA-Z_-]+:.*?## .*$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "  %-20s %s\n", $1, $2}'

install: ## Install dependencies
	$(GOMOD) download
	$(GOMOD) tidy
	@echo "Installing tools..."
	go install github.com/swaggo/swag/cmd/swag@latest
	go install github.com/golang-migrate/migrate/v4/cmd/migrate@latest

build: ## Build the application
	@echo "Building $(APP_NAME)..."
	$(GOBUILD) -ldflags "-X main.Version=$(VERSION)" -o $(BUILD_DIR)/$(APP_NAME) $(MAIN_PATH)
	@echo "Build complete: $(BUILD_DIR)/$(APP_NAME)"

run: ## Run the application
	$(GORUN) $(MAIN_PATH)/main.go

dev: ## Run in development mode with hot reload (requires air)
	air

test: ## Run tests
	$(GOTEST) -v -race -coverprofile=coverage.out ./...
	$(GOCMD) tool cover -html=coverage.out -o coverage.html

test-integration: ## Run integration tests
	$(GOTEST) -v -tags=integration ./test/integration/...

lint: ## Run linter
	golangci-lint run

swagger: ## Generate Swagger documentation
	swag init -g cmd/api/main.go -o internal/docs
	@echo "Swagger docs generated"

migrate-create: ## Create a new migration (use name=migration_name)
	migrate create -ext sql -dir $(MIGRATION_PATH) -seq $(name)

migrate-up: ## Run database migrations
	migrate -path $(MIGRATION_PATH) -database "$(DB_URL)" up

migrate-down: ## Rollback database migrations
	migrate -path $(MIGRATION_PATH) -database "$(DB_URL)" down

migrate-force: ## Force migration version (use version=N)
	migrate -path $(MIGRATION_PATH) -database "$(DB_URL)" force $(version)

clean: ## Clean build artifacts
	rm -rf $(BUILD_DIR)
	rm -rf coverage.out coverage.html
	@echo "Clean complete"

docker-build: ## Build Docker image
	docker build -t $(DOCKER_IMAGE) .
	@echo "Docker image built: $(DOCKER_IMAGE)"

docker-run: ## Run Docker container
	docker-compose up -d

docker-stop: ## Stop Docker containers
	docker-compose down

docker-logs: ## View Docker logs
	docker-compose logs -f

fmt: ## Format code
	go fmt ./...
	goimports -w .

vet: ## Run go vet
	go vet ./...

mod-update: ## Update dependencies
	$(GOMOD) get -u ./...
	$(GOMOD) tidy

security-scan: ## Run security scan
	gosec ./...

bench: ## Run benchmarks
	$(GOTEST) -bench=. -benchmem ./...

coverage: ## Generate coverage report
	$(GOTEST) -coverprofile=coverage.out ./...
	$(GOCMD) tool cover -func=coverage.out

all: clean install swagger build test ## Run all build steps

.DEFAULT_GOAL := help
```

---

### 20. **Dockerfile**

```dockerfile
# Build stage
FROM golang:1.21-alpine AS builder

# Install build dependencies
RUN apk add --no-cache git make

WORKDIR /app

# Copy go mod files
COPY go.mod go.sum ./
RUN go mod download

# Copy source code
COPY . .

# Build the application
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main ./cmd/api

# Final stage
FROM alpine:latest

RUN apk --no-cache add ca-certificates tzdata

WORKDIR /root/

# Copy binary from builder
COPY --from=builder /app/main .

# Copy config files (if needed)
COPY --from=builder /app/config ./config

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

CMD ["./main"]
```

---

### 21. **docker-compose.yml**

```yaml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      - APP_NAME=your-project
      - APP_ENV=development
      - APP_DEBUG=true
      - SERVER_HOST=0.0.0.0
      - SERVER_PORT=8080
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_USER=postgres
      - DB_PASSWORD=postgres
      - DB_NAME=your_project_db
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - JWT_SECRET=your-secret-key-change-this
    depends_on:
      - postgres
      - redis
    networks:
      - app-network

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=your_project_db
    ports:
      - "5432:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - app-network

volumes:
  postgres-data:
  redis-data:

networks:
  app-network:
    driver: bridge
```

---

### 22. **.env.example**

```ini
# Application
APP_NAME=your-project
APP_ENV=development
APP_VERSION=1.0.0
APP_DEBUG=true

# Server
SERVER_HOST=0.0.0.0
SERVER_PORT=8080
SERVER_READ_TIMEOUT=30
SERVER_WRITE_TIMEOUT=30
SERVER_SHUTDOWN_TIMEOUT=5

# Database
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=postgres
DB_NAME=your_project_db
DB_SSLMODE=disable
DB_MAX_OPEN_CONNS=25
DB_MAX_IDLE_CONNS=5
DB_MAX_LIFETIME=5

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
REDIS_DB=0
REDIS_POOL_SIZE=10

# JWT
JWT_SECRET=your-secret-key-change-this-in-production
JWT_ACCESS_EXPIRY=15m
JWT_REFRESH_EXPIRY=168h
JWT_ISSUER=your-project

# Logger
LOG_LEVEL=info
LOG_FORMAT=json
LOG_OUTPUT=stdout
LOG_FILE_PATH=./logs/app.log

# CORS
CORS_ALLOWED_ORIGINS=http://localhost:3000,http://localhost:3001
CORS_ALLOWED_METHODS=GET,POST,PUT,PATCH,DELETE,OPTIONS
CORS_ALLOWED_HEADERS=Origin,Content-Type,Accept,Authorization
CORS_ALLOW_CREDENTIALS=true

# Rate Limiting
RATE_LIMIT_REQUESTS_PER_SECOND=10
RATE_LIMIT_BURST=20

# File Upload
UPLOAD_PROVIDER=s3
UPLOAD_MAX_SIZE=10485760
S3_BUCKET=your-bucket
S3_REGION=us-east-1
S3_ACCESS_KEY=
S3_SECRET_KEY=
```

---

### 23. **Migration Example** (`migrations/000001_create_users_table.up.sql`)

```sql
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    role VARCHAR(50) DEFAULT 'user',
    status VARCHAR(50) DEFAULT 'active',
    last_login_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_users_deleted_at ON users(deleted_at);
```

---

### 24. **README.md**

```markdown
# Go Backend Architecture

Production-grade Go backend API with clean architecture, comprehensive tooling, and developer-friendly patterns.

## ðŸš€ Features

- Clean Architecture with clear separation of concerns
- RESTful API with Gin framework
- PostgreSQL with GORM ORM
- Redis caching
- JWT authentication
- WebSocket support
- Swagger/OpenAPI documentation
- Structured logging with Zap
- Database migrations
- Docker support
- Comprehensive error handling
- Rate limiting
- CORS handling
- Health checks
- Graceful shutdown

## ðŸ“ Project Structure

```

â”œâ”€â”€ cmd/ # Application entrypoints â”œâ”€â”€ internal/ # Private application code â”‚ â”œâ”€â”€ config/ # Configuration â”‚ â”œâ”€â”€ middleware/ # HTTP middleware â”‚ â”œâ”€â”€ modules/ # Feature modules â”‚ â”œâ”€â”€ models/ # Domain models â”‚ â”œâ”€â”€ services/ # Shared services â”‚ â”œâ”€â”€ database/ # Database connections â”‚ â””â”€â”€ utils/ # Utilities â”œâ”€â”€ pkg/ # Public reusable packages â”œâ”€â”€ migrations/ # Database migrations â”œâ”€â”€ docs/ # Documentation â””â”€â”€ deployments/ # Deployment configs

````

## ðŸ› ï¸ Setup

### Prerequisites

- Go 1.21+
- PostgreSQL 14+
- Redis 7+
- Docker & Docker Compose (optional)

### Installation

```bash
# Clone repository
git clone <repository-url>
cd your-project

# Install dependencies
make install

# Copy environment file
cp .env.example .env

# Edit .env with your configuration
````

### Running Locally

```bash
# Run database migrations
make migrate-up

# Generate Swagger docs
make swagger

# Run application
make run

# Or with hot reload (requires air)
make dev
```

### Using Docker

```bash
# Build and run with Docker Compose
make docker-run

# View logs
make docker-logs

# Stop containers
make docker-stop
```

## ðŸ“– API Documentation

Access Swagger UI at: `http://localhost:8080/docs`

## ðŸ§ª Testing

```bash
# Run unit tests
make test

# Run integration tests
make test-integration

# Generate coverage report
make coverage
```

## ðŸ—ï¸ Adding New Modules

1. Create module directory: `internal/modules/your-module/`
2. Implement files: `handler.go`, `service.go`, `repository.go`, `dto/`, `routes.go`
3. Register routes in `cmd/api/main.go`

## ðŸ“ License

MIT

```

---

## ðŸŽ¯ Key Differences from Express Architecture

### **1. Type Safety**
- Go's strong typing catches errors at compile time
- Interfaces define contracts explicitly
- No runtime type errors

### **2. Dependency Injection**
- Constructor-based DI instead of global imports
- Clear dependencies in function signatures
- Easier testing and mocking

### **3. Error Handling**
- Explicit error returns (no try-catch)
- Custom error types with detailed context
- Panic recovery middleware

### **4. Concurrency**
- Goroutines for async operations
- Channels for
```


## ðŸŽ¯ **Key Highlights**

### **1. Clean & Scalable Structure**

- Module-based organization (like your Express setup)
- Clear separation: Handler â†’ Service â†’ Repository
- Easy to add new features without affecting existing code

### **2. Developer-Friendly**

- Single command setup: `make install && make run`
- Hot reload support with Air
- Comprehensive Makefile for all operations
- Clear error messages with context

### **3. Production-Ready**

- Graceful shutdown
- Health checks
- Structured logging (Zap)
- Rate limiting
- CORS handling
- Docker support
- Database migrations

### **4. Type-Safe**

- Go's compiler catches bugs early
- Clear interfaces between layers
- No runtime surprises

### **5. Performance**

- Native concurrency with goroutines
- Connection pooling
- Redis caching
- WebSocket support

## ðŸš€ **Quick Start**

```bash
# Clone and setup
git clone <your-repo>
cd your-project
make install

# Run with Docker
make docker-run

# Or run locally
make migrate-up
make swagger
make run
```