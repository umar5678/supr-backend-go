// package response

// import (
// 	"time"

// 	"github.com/gin-gonic/gin"
// )

// // Response represents the standard API response structure
// type Response struct {
// 	Success bool          `json:"success"`
// 	Message string        `json:"message"`
// 	Data    interface{}   `json:"data,omitempty"`
// 	Errors  []ErrorStruct `json:"errors,omitempty"`
// 	Meta    Meta          `json:"meta"`
// 	Code    string        `json:"code,omitempty"`
// }

// // Error represents a single error detail
// type ErrorStruct struct {
// 	Field   string `json:"field,omitempty"`
// 	Message string `json:"message"`
// 	Code    string `json:"code,omitempty"`
// }

// // Meta contains request metadata
// type Meta struct {
// 	RequestID  string  `json:"requestId"`
// 	Timestamp  string  `json:"timestamp"`
// 	DurationMs float64 `json:"durationMs,omitempty"`
// 	Path       string  `json:"path"`
// 	Method     string  `json:"method"`
// 	Version    string  `json:"version,omitempty"`
// }

// // Success sends a successful response
// func Success(c *gin.Context, data interface{}, message string, code ...string) {
// 	statusCode := 200
// 	if c.Request.Method == "POST" {
// 		statusCode = 201
// 	}

// 	resp := Response{
// 		Success: true,
// 		Message: message,
// 		Data:    data,
// 		Meta:    extractMeta(c),
// 	}

// 	if len(code) > 0 {
// 		resp.Code = code[0]
// 	}

// 	c.JSON(statusCode, resp)
// }

// // Error sends an error response
// func Error(c *gin.Context, statusCode int, message string, errors []ErrorStruct, code ...string) {
// 	resp := Response{
// 		Success: false,
// 		Message: message,
// 		Errors:  errors,
// 		Meta:    extractMeta(c),
// 	}

// 	if len(code) > 0 {
// 		resp.Code = code[0]
// 	}

// 	c.JSON(statusCode, resp)
// }

// // ValidationError sends a validation error response
// func ValidationError(c *gin.Context, errors []ErrorStruct) {
// 	Error(c, 422, "Validation failed", errors, "VALIDATION_ERROR")
// }

// // NotFound sends a 404 response
// func NotFound(c *gin.Context, message string) {
// 	Error(c, 404, message, nil, "NOT_FOUND")
// }

// // Unauthorized sends a 401 response
// func Unauthorized(c *gin.Context, message string) {
// 	Error(c, 401, message, nil, "UNAUTHORIZED")
// }

// // Forbidden sends a 403 response
// func Forbidden(c *gin.Context, message string) {
// 	Error(c, 403, message, nil, "FORBIDDEN")
// }

// // InternalError sends a 500 response
// func InternalError(c *gin.Context, message string) {
// 	Error(c, 500, message, nil, "INTERNAL_ERROR")
// }

// // extractMeta extracts metadata from the context
// func extractMeta(c *gin.Context) Meta {
// 	requestID, _ := c.Get("requestID")
// 	startTime, exists := c.Get("startTime")

// 	meta := Meta{
// 		RequestID: requestID.(string),
// 		Timestamp: time.Now().UTC().Format(time.RFC3339),
// 		Path:      c.Request.URL.Path,
// 		Method:    c.Request.Method,
// 	}

// 	if exists {
// 		duration := time.Since(startTime.(time.Time))
// 		meta.DurationMs = float64(duration.Microseconds()) / 1000
// 	}

// 	version, exists := c.Get("version")
// 	if exists {
// 		meta.Version = version.(string)
// 	}

// 	return meta
// }

// // Paginated sends a paginated response
// func Paginated(c *gin.Context, data interface{}, pagination PaginationMeta, message string) {
// 	resp := Response{
// 		Success: true,
// 		Message: message,
// 		Data:    data,
// 		Meta:    extractMeta(c),
// 	}

// 	// Add pagination to meta
// 	c.Set("pagination", pagination)

// 	c.JSON(200, gin.H{
// 		"success":    resp.Success,
// 		"message":    resp.Message,
// 		"data":       resp.Data,
// 		"meta":       resp.Meta,
// 		"pagination": pagination,
// 	})
// }

// // PaginationMeta represents pagination metadata
// type PaginationMeta struct {
// 	Total      int64 `json:"total"`
// 	Page       int   `json:"page"`
// 	Limit      int   `json:"limit"`
// 	TotalPages int   `json:"totalPages"`
// 	HasNext    bool  `json:"hasNext"`
// 	HasPrev    bool  `json:"hasPrev"`
// }

// // NewPaginationMeta creates pagination metadata
// func NewPaginationMeta(total int64, page, limit int) PaginationMeta {
// 	totalPages := int(total) / limit
// 	if int(total)%limit > 0 {
// 		totalPages++
// 	}

// 	return PaginationMeta{
// 		Total:      total,
// 		Page:       page,
// 		Limit:      limit,
// 		TotalPages: totalPages,
// 		HasNext:    page < totalPages,
// 		HasPrev:    page > 1,
// 	}
// }
